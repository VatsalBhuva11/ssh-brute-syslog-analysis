input {
  file {
    path => "/var/log/auth.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "plain"
    tags => ["ssh", "auth"]
  }
}

filter {
  # Parse syslog format: timestamp hostname service[pid]: message
  grok {
    match => { 
      "message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host} %{WORD:service}\[%{NUMBER:pid}\]: %{GREEDYDATA:event}" 
    }
    tag_on_failure => ["_grokparsefailure_syslog"]
  }

  # Parse SSH authentication events
  # Matches: "Failed password for invalid user xyz from 192.168.0.1 port 22 ssh2"
  # Matches: "Accepted password for user from 192.168.0.1 port 22 ssh2"
  grok {
    match => {
      "event" => "(?<status>Failed|Accepted) password for (invalid user )?(?<user>\S+) from %{IP:src_ip} port %{NUMBER:port} %{WORD:protocol}"
    }
    tag_on_failure => ["_grokparsefailure_ssh"]
  }

  # Parse connection events
  # Matches: "Connection from 192.168.0.1 port 22"
  grok {
    match => {
      "event" => "Connection from %{IP:src_ip} port %{NUMBER:port}"
    }
    add_tag => ["connection"]
  }

  # Parse disconnection events
  # Matches: "Disconnected from user 192.168.0.1 port 22"
  grok {
    match => {
      "event" => "Disconnected from (user )?%{IP:src_ip} port %{NUMBER:port}"
    }
    add_tag => ["disconnection"]
  }

  # Parse invalid user attempts
  # Matches: "Invalid user admin from 192.168.0.1 port 22"
  grok {
    match => {
      "event" => "Invalid user %{USERNAME:user} from %{IP:src_ip} port %{NUMBER:port}"
    }
    add_tag => ["invalid_user"]
  }

  # Add severity based on status
  if [status] == "Failed" {
    mutate {
      add_field => { "severity" => "warning" }
      add_tag => ["failed_login"]
    }
  } else if [status] == "Accepted" {
    mutate {
      add_field => { "severity" => "info" }
      add_tag => ["successful_login"]
    }
  }

  # Add attack indicator for multiple failed attempts
  # This will be better handled in Kibana with aggregations, but we can tag here
  if "failed_login" in [tags] {
    mutate {
      add_tag => ["potential_brute_force"]
    }
  }

  # Parse timestamp
  date {
    match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    target => "@timestamp"
    timezone => "UTC"
  }

  # Add hostname if not present
  if ![host] {
    mutate {
      add_field => { "host" => "unknown" }
    }
  }

  # Clean up fields
  mutate {
    remove_field => ["@version"]
  }
}

output {
  elasticsearch {
    hosts => ["http://localhost:9200"]
    index => "authlogs"
    # Optional: Use template if available
    # template_name => "authlogs"
    # template => "/usr/share/logstash/templates/authlogs-template.json"
    # template_overwrite => true
  }
  stdout { 
    codec => rubydebug 
  }
}
