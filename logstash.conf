input {
  file {
    path => "/var/log/auth.log"
    start_position => "end"  # Only read new entries after restart
    sincedb_path => "/usr/share/logstash/data/sincedb"  # Persist read position
    codec => "plain"
    tags => ["ssh", "auth"]
  }
}

filter {
  # Drop sudo entries if you only want SSH logs
  # Uncomment the next 3 lines to filter out sudo logs:
  if [service] == "sudo" {
    drop { }
  }
  
  # Parse syslog format: timestamp hostname service[pid]: message
  grok {
    match => { 
      "message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host} %{WORD:service}\[%{NUMBER:pid}\]: %{GREEDYDATA:event}" 
    }
    tag_on_failure => ["_grokparsefailure_syslog"]
  }

  # Parse SSH authentication events
  # Matches: "Failed password for invalid user xyz from 192.168.0.1 port 22 ssh2"
  # Matches: "Accepted password for user from 192.168.0.1 port 22 ssh2"
  grok {
    match => {
      "event" => "(?<status>Failed|Accepted) password for (invalid user )?(?<user>\S+) from %{IP:src_ip} port %{NUMBER:port} %{WORD:protocol}"
    }
    tag_on_failure => ["_grokparsefailure_ssh"]
  }

  # Parse connection events
  # Matches: "Connection from 192.168.0.1 port 22"
  grok {
    match => {
      "event" => "Connection from %{IP:src_ip} port %{NUMBER:port}"
    }
    add_tag => ["connection"]
  }

  # Parse disconnection events
  # Matches: "Disconnected from user 192.168.0.1 port 22"
  grok {
    match => {
      "event" => "Disconnected from (user )?%{IP:src_ip} port %{NUMBER:port}"
    }
    add_tag => ["disconnection"]
  }

  # Parse invalid user attempts
  # Matches: "Invalid user admin from 192.168.0.1 port 22"
  grok {
    match => {
      "event" => "Invalid user %{USERNAME:user} from %{IP:src_ip} port %{NUMBER:port}"
    }
    add_tag => ["invalid_user"]
  }

  # Add severity based on status
  if [status] == "Failed" {
    mutate {
      add_field => { "severity" => "warning" }
      add_tag => ["failed_login"]
    }
  } else if [status] == "Accepted" {
    mutate {
      add_field => { "severity" => "info" }
      add_tag => ["successful_login"]
    }
  }

  # GeoIP enrichment (skip private/reserved ranges)
  if [src_ip] and
     !([src_ip] =~ /^127\./ or
        [src_ip] =~ /^10\./ or
        [src_ip] =~ /^192\.168\./ or
        [src_ip] =~ /^172\.(1[6-9]|2[0-9]|3[0-1])\./ or
        [src_ip] =~ /^169\.254\./ or
        [src_ip] =~ /^0\./) {
    geoip {
      source => "src_ip"
      target => "geoip"
      add_tag => ["geoip_enriched"]
      tag_on_failure => ["_geoip_lookup_failure"]
    }

    mutate {
      convert => {
        "[geoip][latitude]" => "float"
        "[geoip][longitude]" => "float"
      }
    }
  }

  # Convert timestamp to proper format
  # Note: SYSLOGTIMESTAMP doesn't include year, so we need to add it
  # The timestamp is in local time, so we parse it and let Logstash handle timezone
  date {
    match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    target => "@timestamp"
    timezone => "Asia/Qatar"  # Your system timezone (+03)
  }
}

output {
  elasticsearch {
    hosts => ["http://localhost:9200"]
    index => "authlogs"
  }
}